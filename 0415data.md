# 保留字

**0414补充**
string
slice
&
\[]
<>
：：
ptr

**0415**
..
alloc
as_mut_ptr
free
from_raw 
from_raw_in
from_raw_parts
from_raw_parts_mut
into_raw 
into_raw_with_allocator
libc
len
malloc
new_in
self
key
get
get_mut_unchecked
get_unchecked
get_unchecked_mut
set_len

# data整理0415


- 第一个（ ）表示std库中代码对数量，第二个（ ）表示github库中代码对数量
- unsafe序列按照相近程度放在一起

## from_raw(7)(1)
- unsafe1  创建Box\<i32>，into_raw转换，from_raw转换后 drop
  - safe方式为drop裸指针
- unsafe2  创建Box\<i32>，into_raw转换，from_raw转换后使用
  - safe方式为into_raw与from_raw成对删除 new后直接使用
- unsafe4  创建Box\<string>，into_raw转换，from_raw转换后使用
  - safe方式为into_raw与from_raw成对删除 new后直接使用
- 扩充unsafe6 创建Rc\<i32>，into_raw转换，from_raw转换后使用
  - safe方式为into_raw与from_raw成对删除 new后直接使用
- unsafe5  创建Rc\<String>，into_raw转换，from_raw转换后使用
  - safe方式为into_raw与from_raw成对删除 new后直接使用
- unsafe3  将alloc返回的裸指针强制转换指向 i32 类型的指针，from_raw转换成Box\<i32>后使用
  - safe方式为删除alloc与from_raw new后直接使用
- 扩充unsafe7 将alloc返回的裸指针强制转换指向 i32 类型的指针，from_raw转换成Rc\<i32>后使用
  - safe方式为删除alloc与from_raw new后直接使用

修改 safe5 
```
#![allow(unused)]
use std::ops::Deref;
fn main() {
    use std::rc::Rc;

    let x = Rc::new("hello".to_owned());

    assert_eq!( &*x , "hello");
    // assert_eq!(x.deref(), "hello");
    // x.deref() 和 &*x 都是将 Rc<String> 转换为 &str 类型的引用
    // 原unsafe代码此处为&*x 不需要修改 

}
```

扩充 unsafe6
```
use std::alloc::{alloc, Layout};
use std::rc::Rc;

fn main() {
    let x = Rc::new(42);
    x_ptr = Rc::into_raw(x.clone());
    x = unsafe { Rc::from_raw(x_ptr) };
    assert_eq!(*x, 42);

}
```
对应 safe6
```
use std::rc::Rc;

fn main() {
    let x = Rc::new(42);
    //  let x_clone = x.clone();
    //  let x = Rc::clone(&x_clone);
    assert_eq!(*x, 42);
}

```
扩充 unsafe7
```
use std::alloc::{alloc, Layout};
use std::rc::Rc;

fn main() {
    let ptr = unsafe { alloc(Layout::new::<i32>()) } as *mut i32;
    unsafe { ptr.write(42) };
    let rc = unsafe { Rc::from_raw(ptr) };
    assert_eq!(*rc, 42);
}
```
对应 safe7
```
use std::rc::Rc;

fn main() {
    let rc = Rc::new(42);
    assert_eq!(*rc, 42);
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
github unsafe（???没看懂）
```
#![allow(unused)]

fn main() {
    let mut ptr: *mut sys::JavaVM = ::std::ptr::null_mut();
    let mut env: *mut sys::JNIEnv = ::std::ptr::null_mut();

    unsafe {
        jni_error_code_to_result(sys::JNI_CreateJavaVM(
            &mut ptr as *mut _,
            &mut env as *mut *mut sys::JNIEnv as *mut *mut c_void,
            args.inner_ptr(),
        ))?;
        let vm = Self::from_raw(ptr)?;
        java_vm_unchecked!(vm.0, DetachCurrentThread);
        Ok(vm)
    }

}
```
github safe
```
#![allow(unused)]

fn main() {
    let mut ptr: *mut sys::JavaVM = ::std::ptr::null_mut();
    let mut env: *mut sys::JNIEnv = ::std::ptr::null_mut();

    jni_error_code_to_result(create_fn_ptr(
        &mut ptr as *mut _,
        &mut env as *mut *mut sys::JNIEnv as *mut *mut c_void,
        args.inner_ptr(),
    ))?;

    Ok(vm)

}
```
## from_raw_in(3)(0)
- unsafe1  new_in使用 System 分配器创建Box\<i32>,into_raw_with_allocator获得指向内存地址的原始裸指针和分配器,from_raw_in
  - safe方式为直接new_in
- unsafe2  allocate后转成i32裸指针后from_raw_in
  - safe方式为直接new_in
- unsafe3  new_in使用 System 分配器创建Box\<string>,into_raw_with_allocator获得指向内存地址的原始裸指针和分配器,from_raw_in
  - safe方式为直接new_in
## from_raw_parts(4)(2)
- unsafe1 使用了裸指针来获取一个变量的地址并将其转换为切片
  - safe方式使用slice::from_ref方法将变量的引用转换为切片
- 扩充unsafe2 将一个数组的指针转换为切片
  - safe方式直接使用数组的切片方法[..]来获取一个数组的切片
- 扩充unsafe3（与github中的unsafe2对应）
  - from_raw_parts 函数来创建切片的方式改为直接引用结构体中的内部字段来创建切片
- 扩充unsafe4（与github中的unsafe1对应）
  - 修改使用 mem::replace 函数替换了 slice 变量的值
  
补充 unsafe2
```
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let ptr = arr.as_ptr(); // 获取数组的指针
    let len = arr.len(); // 获取数组的长度
    unsafe {
        let slice = std::slice::from_raw_parts(ptr, len); // 使用from_raw_parts方法将指针转换为切片
        println!("{:?}", slice); 
    }
}

```
对应 safe2
```
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[..]; // 获取数组的切片
    println!("{:?}", slice); // 打印切片
}

```
补充 unsafe3（修改模式与github中的unsafe2对应）
```
struct MyStruct {
    data: [i32; 5],
}

impl MyStruct {
    fn get_slice(&self) -> &[i32] {
        &self.data[..]
    }
}

fn main() {
    let arr = [1, 2, 3, 4, 5];
    let ptr = arr.as_ptr();
    let len = arr.len();
    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };
    println!("{:?}", slice);
}

```
对应 safe3
```
struct MyStruct {
    data: [i32; 5],
}

impl MyStruct {
    fn get_slice(&self) -> &[i32] {
        &self.data[..]
    }
}

fn main() {
    let my_struct = MyStruct {
        data: [1, 2, 3, 4, 5],
    };
    let slice = my_struct.get_slice();
    println!("{:?}", slice);
}
```
补充 unsafe4（修改模式与github中的unsafe1对应）
```
fn main() {
    let mut data = [1, 2, 3, 4, 5];
    let ptr = data.as_ptr();
    let len = data.len();
    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };
    let new_slice = &slice[1..4];
    println!("{:?}", new_slice);
}
```
对应 safe4
```
fn main() {
    let mut data = [1, 2, 3, 4, 5];
    let mut slice = &mut data[..];
    let new_slice = std::mem::replace(&mut slice, &mut []);
    let replaced_slice = &new_slice[1..4];
    println!("{:?}", replaced_slice);
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

github unsafe1
```
pub(crate) fn increment_by<T>(slice: &mut &[T], amount: usize) {
    let lifetime_hack = unsafe {
        // 先切片中的前 amount 个元素移除
        let slice_ptr = slice.as_ptr();
        ::std::slice::from_raw_parts(slice_ptr, slice.len())
        // 使用了 from_raw_parts 函数，将一个指针和长度转换为切片
    };
    *slice = &lifetime_hack[amount..]

}
```
github safe1
```
pub(crate) fn increment_by<T>(slice: &mut &[T], amount: usize) {
    //使用了 mem::replace 函数替换了 slice 变量的值。mem::replace 函数会返回变量之前的值，并将变量的新值设置为传入的值。在这里将 slice 变量替换为一个空切片 &[]，并通过切片操作 [amount..] 从这个空切片中获取了一个新的切片，从而达到unsafe类似的目的

    *slice = &core::mem::replace(slice, &[])[amount..]
    // 直接对结构体中的内部字段进行了引用，并使用了 mem::replace 函数来替换原先的空切片
}
```
github unsafe2（对应std unsafe3）
```
impl AsRef<[u8]> for Inner {
    fn as_ref(&self) -> &[u8] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
        
    }
}
```
github safe2
```
impl AsRef<[u8]> for Inner {
    fn as_ref(&self) -> &[u8] {
        
        self.buf()
    }
}
```
## from_raw_parts_mut(3)(2)
- unsafe1 from_raw_parts_mut(ptr, 1)
  - safe方式 使用from_mut替换from_raw_parts_mut，因为此代码创建的切片只包含一个元素
- 扩充unsafe2 （与github中的unsafe1对应）
- 扩充unsafe3 （与github中的unsafe2对应）
  - 扩充的2、3与from_raw_parts相似，修改为可变引用的切片


补充 unsafe2（修改模式与github中的unsafe1对应）
```
fn main() {
    let mut data = [1, 2, 3, 4, 5];
    let ptr = data.as_mut_ptr();
    let len = data.len();
    let slice = unsafe { std::slice::from_raw_parts_mut(ptr, len) };
    let new_slice = &mut slice[1..4];
    println!("{:?}", new_slice);
}

```
对应 safe2
```
fn main() {
    let mut data = [1, 2, 3, 4, 5];
    let mut slice = &mut data[..];
    let new_slice = std::mem::replace(&mut slice, &mut []);
    let replaced_slice = &mut new_slice[1..4];
    println!("{:?}", replaced_slice);
}

```
补充 unsafe3（修改模式与github中的unsafe2对应）
```
struct MyStruct {
    data: [i32; 5],
}

impl MyStruct {
    fn get_slice(&mut self) -> &mut [i32] {
        &mut self.data[..]
    }
}

fn main() {
    let mut my_struct = MyStruct { data: [0; 5] };
    let ptr = my_struct.get_slice().as_mut_ptr();
    let len = my_struct.get_slice().len();
    let slice = unsafe { std::slice::from_raw_parts_mut(ptr, len) };
    slice.copy_from_slice(&[1, 2, 3, 4, 5]);
    println!("{:?}", my_struct.data);
}


```
对应 safe3
```
struct MyStruct {
    data: [i32; 5],
}

impl MyStruct {
    fn get_slice_mut(&mut self) -> &mut [i32] {
        &mut self.data[..]
    }
}

fn main() {
    let mut my_struct = MyStruct {
        data: [1, 2, 3, 4, 5],
    };
    let slice = my_struct.get_slice_mut();
    slice[0] = 10;
    println!("{:?}", slice);
}

```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
github unsafe1
```
pub(crate) fn increment_by_mut<T>(slice: &mut &mut [T], amount: usize) {
    let lifetime_hack = unsafe {
        let slice_ptr = slice.as_mut_ptr();
        ::std::slice::from_raw_parts_mut(slice_ptr, slice.len())
    };
    *slice = &mut lifetime_hack[amount..]

}
```
github safe1
```
pub(crate) fn increment_by_mut<T>(slice: &mut &mut [T], amount: usize) {

    *slice = &mut core::mem::replace(slice, &mut [])[amount..]
}
```
github unsafe2
```
impl AsMut<[u8]> for Inner {
    fn as_mut(&mut self) -> &mut [u8] {
        unsafe { std::slice::from_raw_parts_mut(self.ptr, self.len) }
        
    }
}
```
github safe2
```
impl AsMut<[u8]> for Inner {
    fn as_mut(&mut self) -> &mut [u8] {
        
        self.buf_mut()
    }
}
```

## from_u32_unchecked(2)(0)
- unsafe1 将 u32 类型的值转换成chart
- unsafe2 将 u32 类型的值转换成chart
  - safe方式均为将from_u32_unchecked改为from_u32
  - 1、2区别在于Unicode 1无效2有效，本质没区别

修改 safe1
```
/*
fn main() {
    char::from_u32(0x110000);
}
*/
fn main() {
    let c = char::from_u32(0x110000);
    if let Some(c) = c {
        println!("Valid Unicode character: {}", c);
    } else {
        println!("Invalid Unicode character");
    }
}

```

## get_mut_unchecked(1)(0)
- unsafe 调用 get_mut_unchecked() 方法获取Rc的可变引用，在 unsafe 代码块中改 String 对象

  - safe方式调用Rc::get_mut方法获取可变引用
## get_unchecked(5)(2)
- unsafe2（合并1 2 3 5）在不进行边界检查的情况下获取一个数组中的元素
- unsafe4 在不进行边界检查的情况下获取Unicode字符的slice
- 扩充unsafe6 在不进行边界检查的情况下获取一个slice中的元素
- 扩充unsafe7 在不进行边界检查的情况下获取指定索引位置上的key
- 扩充unsafe8 进行边界检查的情况下获取指定索引位置上的value

补充 unsafe6
```
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..4]; // 获取数组 arr 中索引 1 到 3 的 slice
    // 使用 get_unchecked 方法获取 slice 中的元素，这里获取索引为 1 的元素
    let element = unsafe { slice.get_unchecked(1) };
    println!("{}", element);
}
```
对应 safe6
```
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..4]; 
    let element = slice.get(1); // 使用 get 方法替代 get_unchecked 方法
    if let Some(e) = element {
        println!("{}", e);
    } else {
        println!("Failed");
    }
}

```

补充 unsafe7（与github unsafe1 对应）
```
fn main() {
    struct MyStruct<K, V> {
        map: Vec<(K, V)>,
        idx: usize,
    }

    impl<K, V> MyStruct<K, V> {
        pub fn key(&self) -> &K {
            unsafe {
                let (key, _) = self.map.get_unchecked(self.idx);
                key
            }
        }
    }

    let my_struct = MyStruct {
        map: vec![("foo", 42)],
        idx: 0,
    };
    println!("{}", my_struct.key()); // output: "foo"
}

```
对应 safe7
```
fn main() {
    struct MyStruct<K, V> {
        map: Vec<(K, V)>,
        idx: usize,
    }

    impl<K, V> MyStruct<K, V> {
        pub fn key(&self) -> &K {
            let (key, _) = &self.map[self.idx];
            // 接使用 & 取出 self.map 中对应索引位置上的key用 get_unchecked 函数
            key
        }
    }

    let my_struct = MyStruct {
        map: vec![("foo", 42)],
        idx: 0,
    };
    println!("{}", my_struct.key()); // output: "foo"
}

```
补充 unsafe8（与github unsafe2对应））
```
// 声明一个包含两个泛型参数 K 和 V 的结构体 MyStruct
struct MyStruct<K, V> {
    map: Vec<(K, V)>, // 存储键值对的 Vec
    idx: usize, // 记录要访问的键值对在 Vec 中的索引
}

impl<K, V> MyStruct<K, V> {
    // 定义一个公共方法 get，返回当前实例指定索引位置上的值的不可变引用
    pub fn get(&self) -> &V {
        unsafe {
            let (_, value) = self.map.get_unchecked(self.idx); // 获取指定索引位置上的值
            value // 返回值的不可变引用
        }
    }
}
// 创建一个 MyStruct 实例，并输出它在指定索引位置上的值
let my_struct = MyStruct {
    map: vec![("foo", 42)], // 创建包含一组键值对的 Vec
    idx: 0, // 指定要访问的键值对的索引
};
println!("{}", my_struct.get()); 


```
对应 safe8
```
fn main() {
    struct MyStruct<K, V> {
        map: Vec<(K, V)>,
        idx: usize,
    }

    impl<K, V> MyStruct<K, V> {
        pub fn get(&self) -> &V {
        // 直接使用 & 取出 self.map 中对应索引位置上的value，，无需使用 get_unchecked 函数
            let (_, value) = &self.map[self.idx];
            value
        }
    }

    let my_struct = MyStruct {
        map: vec![("foo", 42)],
        idx: 0,
    };
    println!("{}", my_struct.get()); // output: 42
}


```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
github unsafe1（与上std unsafe7对应)
```
##[inline]
pub fn key(&self) -> &K {
    // 调用了 get_unchecked 方法，从 self.map.store 中获取索引为 self.idx 的元素的 key 字段
    unsafe { &self.map.store.get_unchecked(self.idx).key }

}
```
github safe1
```
#[inline]
pub fn key(&self) -> &K {

    match &*self.pair {
        Some(pair) => &pair.key,
        None => unreachable!(),
    }
}
```
github unsafe2（与上std unsafe7对应)
```
#[inline]
pub fn get(&self) -> &V {
    unsafe { 
        // get_unchecked()绕过运行时索引检查来获取指定索引位置上的值
        if let Node { value: Some(v), .. } = self.map.store.get_unchecked(self.idx) {
            v
        } else {
            unreachable!()
        }

    }
}
```
github safe2
```
#[inline]
pub fn get(&self) -> &V {

    match &*self.pair {
        Some(pair) => &pair.value,
        None => unreachable!(),
    }
}
```
## get_unchecked_mut(3)(5)
- unsafe1 获取可变引用的指定位置上的元素，并将其地址与原数组中的地址进行比较
- unsafe2 修改一个可变切片中指定位置的值
- unsafe3  使用get_unchecked_mut获取可变字符串的指定子串
- 扩充unsafe4 使用 get_unchecked_mut 方法获取整型的 Vec 对象从下标 1 到 2 的切片，并将该切片中的元素都加 1

补充 unsafe4
```
fn main() {
    let mut vec = vec![1, 2, 3];
    // 创建了一个 Vec 对象，并使用 get_unchecked_mut 方法获取一个元素切片
    let slice = unsafe { vec.get_unchecked_mut(1..3) };
    for elem in slice {
        *elem += 1;
    }
    println!("{:?}", vec); 
}
```
对应 safe4
```
fn main() {
    let mut vec = vec![1, 2, 3];
    if let Some(slice) = vec.get_mut(1..3) {
        for elem in slice {
            *elem += 1;
        }
        println!("{:?}", vec); 
    }
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

## libc_malloc
- unsafe1 使用 libc::malloc 分配了堆上的内存空间，需要使用 libc::free 来释放
  - safe方式 引用获取堆栈上的内存空间，使用 drop 释放指针
## transmute
- unsafe1 将字节数组转换为无符号整数
  - safe方式使用from_be_bytes将字节数组转换为整数类型
- unsafe2 将指向i32类型变量的指针转换为一个usize类型的值
  - safe方式使用as操作符来将指针转换为整数类型
- 扩充unsafe3 将一个 u32 类型的数字转换为一个 i32 类型的数字

补充 unsafe3
```
fn main() {
    let x: u32 = 12345;
    let y: i32 = unsafe { std::mem::transmute(std::num::NonZeroU32::new_unchecked(x)) };
    println!("{} as i32 is {}", x, y);
}
```
对应 safe3
```
use std::convert::TryFrom;

fn main() {
    let x: u32 = 12345;
    let y = i32::try_from(x).unwrap();//try_from失败就返回一个result
    println!("{} as i32 is {}", x, y);
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

## set_len
- unsafe1 set_len将一个二维向量的长度设置为0
  - safe方式使用 Vec::clear() 方法来安全地清空向量
- unsafe2 对 vec 进行截断，只保留前两个元素
  - safe方式使用Vec.truncate() 将 vec 截断

补充 unsafe2
```
fn main() {
    let mut vec = vec![1, 2, 3];
    unsafe {
       vec.set_len(2);
       }
       assert_eq!(vec, vec![1, 2]);
}
```
对应 safe2
```
fn main(){
    let mut vec = vec![1, 2, 3];
    // 使用 vec.truncate(2) 将 vec 截断为长度为 2。这意味着第三个元素将从 vec 中移除
    vec.truncate(2);
    assert_eq!(vec, vec![1, 2]);
}
```
