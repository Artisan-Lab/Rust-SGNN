# 保留字

'array_assume_init'、'assume_init'、'as_mut_ptr'、'as_uninit_ref'、'as_ref'、'as_bytes_mut'、'as_chunks_unchecked_mut'、'as_chunks_unchecked'、'Box'、'drop'、'dealloc'、'deallocate'、'drop_in_place'、'downcast_unchecked'、'forget'、'from_le_bytes'、'into_raw'、'into_raw_with_allocator'、'mut'、'MaybeUninit'、'new'、'new_in'、'new_uninit'、'new_zeroed'、'new_unchecked'、'new_uninit_slice'、'new_zeroed_slice'、'Rc'、'struct'、'uninit'、'uninit_array'、'Vec'、'write'


# data整理0414


- 第一个（ ）表示std库中代码对数量，第二个（ ）表示github库中代码对数量

## array_assume_init(2)(1)
- unsafe2 与1不同于unsafe修改后的应用场景
  - 修改方法均为预先对array初始化

扩充 unsafe2 
```
#![feature(maybe_uninit_uninit_array)]
#![feature(maybe_uninit_array_assume_init)]

use std::mem::MaybeUninit;

fn main(){
    let mut a:[MaybeUninit<u8>; 4] = MaybeUninit::uninit_array();
    a[0].write(0);
    a[1].write(1);
    a[2].write(2);
    a[3].write(3);
    let b = u32::from_le_bytes(unsafe { MaybeUninit::array_assume_init(a) });
}
```
对应 safe2
```
fn main(){
    let mut a:[u8; 4]=[0,1,2,4];
    let b = u32::from_le_bytes(a);
    println!("{}",b);
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

github unsafe（与上std unsafe2 对应)
```
#[inline]
fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {
    let mut bytes = MaybeUninit::uninit_array();
    let _start_pos = decoder.position();
    decoder.read_raw_bytes(&mut bytes)?;

    let _end_pos = decoder.position();
    debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);

    let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });

    Ok(IntEncodedWithFixedSize(value))
}
```
github safe
```
#[inline]
fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {
    let mut bytes = MaybeUninit::uninit_array();
    let _start_pos = decoder.position();
    decoder.read_raw_bytes(&mut bytes)?;

    let _end_pos = decoder.position();
    debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);

    let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });

    Ok(IntEncodedWithFixedSize(value))
}
```
## as_bytes_mut(2)（0）
- unsafe1 调用 String 类型的 as_bytes_mut() 方法，并将其返回的可变字节数组绑定到变量上
  - safe方式使用 as_bytes 方法来获取不可变的字节数组引用
- unsafe2 相比1来说多了对字符的修改操作
  - safe 方式先将字符串 s 转换为可变字符串，再替换字符，最后将字符串转换为不可变的
  

补充 unsafe 2.rs
```
fn main(){
    let mut s = String::from("🗻∈🌏");
    unsafe {
        let bytes = s.as_bytes_mut();
        bytes[0] = 0xF0;
        bytes[1] = 0x9F;
        bytes[2] = 0x8D;
        bytes[3] = 0x94;
    }
    assert_eq!("🍔∈🌏", s);
}
```
对应 safe 2.rs
```
fn main(){
    let mut s = String::from("🗻∈🌏");
// 将字符串转换为可变字符串
    let mut chars = s.chars().collect::<Vec<_>>();
// 替换第一个字符
    chars[0] = '🍔';
// 将字符数组转换为字符串
    s = chars.into_iter().collect();
    assert_eq!("🍔∈🌏", s);
}
```
## as_chunks_unchecked (1)(0)
- unsafe1 as_chunks_unchecked 方法来将一个字符切片分成多个固定大小的块，并返回一个数组的引用
  - safe方式使用chunks_exact方法对切片进行切分，确保每个切片块的长度都相等且不超过原始切片的长度

## as_chunks_unchecked_mut(1)(0)
- unsafe1 创建一个可变的字符 slice使用as_chunks_unchecked_mut 方法来将一个字符切片分成多个固定大小的块,
  - safe方式使用chunks_exact方法对切片进行切分

## as_ref(2)(0)
- unsafe1 通过as_ref()方法将不可变指针转化为Option<&T>类型
  - safe方式创建一个指向u8类型变量10的不可变指针，并将其封装到Rc中，通过Deref trait获取指针所指向的值
- unsafe2 使用as_ref()方法将NonNull类型的指针转化为引用类型
  - safe方式将变量包装成一个引用计数智能指针Rc，使用deref()方法获取指针内部数据的引用
  -  - 1、2 修改方式无区别
## as_uninit_ref(1)(0)
- unsafe1 将指针转化为Option<MaybeUninit<&T>>类型
  - safe方式 new()然后deref()
## assume_init(11)(1)
- unsafe1 (原1 3 15 5 6)  Box::<u32>::new_uninit()
- unsafe19 （原19 25 21）  Rc::<u32>::new_uninit()
- 17 （原17 18）   MaybeUninit::<UnsafeCell<i32>>::uninit()
- 2  （原2 4 7 8） Box::<u32>::new_zeroed()
- 10 （原10 12 14） Box new_zeroed_slice(3) 
- 20 （原20 22 ）   Rc::<u32>::new_zeroed() 
- 24               Rc new_zeroed_slice(3)
- 9  （原9 16 11 13 ） Box new_uninit_slice
- 23              Rc new_uninit_slice
- 26              MaybeUninit::uninit().assume_init()
   - 方法均为直接new不再延迟初始化 
   
补充unsafe26（与GitHub case对应）
```
use std::mem::MaybeUninit;

fn main() {
    let mut v: [MaybeUninit<Vec<i32>>; 10] = unsafe { MaybeUninit::uninit().assume_init() };
}

```
对应 safe26
```
fn main() {
    const EMPTY_VEC: Vec<i32> = Vec::new();
    let mut m = [EMPTY_VEC; 10];
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Github unsafe（与上std unsafe26 对应)
```
#![allow(unused)]
use std::mem::MaybeUninit;
fn main() {
    let mut m: [MaybeUninit<String>; 256] = unsafe { MaybeUninit::uninit().assume_init() };
}
```
Github safe
```
#![allow(unused)]
fn main() {
    const EMPTY_STRING: String = String::new();
    let mut m = [EMPTY_STRING; 256];
}
```
### dealloc(2)(0)

- unsafe1 把 Box 转换成裸指针，使用drop_in_place 手动调用指针指向对象的析构函数，然后使用 dealloc 函数释放指针指向的内存
  - safe方式为 drop(p)
- unsafe2 将 Box 转化为裸指针和分配器 Box::into_raw_with_allocator(x)最后释放分配器中的内存alloc.deallocate
  - safe方式为drop(ptr)、drop(alloc)
  - -  1、2的主要区别是分配方式和释放函数不同
### downcast_unchecked(1)(0)
- unsafe1 使用了 downcast_unchecked() 方法来将变量类型是 Box\<dyn Any> 的x中的值转换成 usize 类型
  - safe方式为使用 if let 和 downcast() 方法

### drop_in_place(4)(0)
- unsafe1 释放指向实现了 Drop trait 的string的指针 
- unsafe2 释放基本类型 i32  的指针 
- unsafe3..18 释放余下16基本类型的指针
- unsafe19 释放自定义类型Vec<u8> 
- unsafe20 释放包含在Vec容器中的对象（上述容器均为Box）
---------------------------------------修改方法均为drop（）
补充 unsafe 2.rs
```
fn main() {
    let mut x = 123;
    let p = &mut x as *mut i32;
    // 通过 &mut x 取出 x 的可变引用，并将其转换成了一个 *mut i32 类型的原始指针 p，表示指向 x 所在的内存地址

    unsafe {
        std::ptr::drop_in_place(p);
        // 手动释放了 i32 类型对象所占用的内存
    }
}

```
对应 safe 2.rs 
```
fn main() {
    let mut x = 123;
    std::mem::drop(x);
}
```
补充 unsafe 19.rs
```
// 定义一个包含 Vec<u8> 数据的自定义类型 MyStruct
struct MyStruct {
    data: Vec<u8>,
}

// 为 MyStruct 类型实现 Drop trait
impl Drop for MyStruct {
    fn drop(&mut self) {
        // 在对象被释放时打印一条消息
        println!("Dropping MyStruct");
    }
}

fn main() {
    // 创建一个 MyStruct 对象并初始化它的 data 字段
    let my_struct = MyStruct {
        data: vec![1, 2, 3],
    };

    // 将 MyStruct 对象转换为 Box，并获取它的原始指针
    let ptr = Box::into_raw(Box::new(my_struct));

    // 使用 unsafe 块和 drop_in_place 函数释放指针所指向的对象的内存
    unsafe {
        std::ptr::drop_in_place(ptr);
    }
}

```
对应 safe 19.rs 
```
struct MyStruct {
    data: Vec<u8>,
}
impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Dropping MyStruct");
    }
}

fn main() {
    let my_struct = MyStruct {
        data: vec![1, 2, 3],
    };
    let ptr = Box::leak(Box::new(my_struct));
    std::mem::drop(ptr);
}

```
补充 unsafe 20.rs
```
fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let p = v.as_mut_ptr();
    let len = v.len();
    // 强制忘记这个 Vec，使内存不会被自动释放
    std::mem::forget(v);

    unsafe {
        for i in 0..len {
            std::ptr::drop_in_place(p.add(i));
        }
        std::alloc::dealloc(p as *mut u8, std::alloc::Layout::new::<i32>());
    }
}

```
对应 safe 20.rs
```
fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let mut v = std::mem::take(&mut v); // 通过take函数获取Vec中的所有权并将其置为空，避免使用forget函数
    while let Some(val) = v.pop() {  // 通过pop函数获取Vec中的元素并释放
        drop(val);
    }
}

```
