# ä¿ç•™å­—

'array_assume_init'ã€'assume_init'ã€'as_mut_ptr'ã€'as_uninit_ref'ã€'as_ref'ã€'as_bytes_mut'ã€'as_chunks_unchecked_mut'ã€'as_chunks_unchecked'ã€'Box'ã€'drop'ã€'dealloc'ã€'deallocate'ã€'drop_in_place'ã€'downcast_unchecked'ã€'forget'ã€'from_le_bytes'ã€'into_raw'ã€'into_raw_with_allocator'ã€'mut'ã€'MaybeUninit'ã€'new'ã€'new_in'ã€'new_uninit'ã€'new_zeroed'ã€'new_unchecked'ã€'new_uninit_slice'ã€'new_zeroed_slice'ã€'Rc'ã€'struct'ã€'uninit'ã€'uninit_array'ã€'Vec'ã€'write'


# dataæ•´ç†0414


- ç¬¬ä¸€ä¸ªï¼ˆ ï¼‰è¡¨ç¤ºstdåº“ä¸­ä»£ç å¯¹æ•°é‡ï¼Œç¬¬äºŒä¸ªï¼ˆ ï¼‰è¡¨ç¤ºgithubåº“ä¸­ä»£ç å¯¹æ•°é‡

## array_assume_init(2)(1)
- unsafe2 ä¸1ä¸åŒäºunsafeä¿®æ”¹åçš„åº”ç”¨åœºæ™¯
  - ä¿®æ”¹æ–¹æ³•å‡ä¸ºé¢„å…ˆå¯¹arrayåˆå§‹åŒ–

æ‰©å…… unsafe2 
```
#![feature(maybe_uninit_uninit_array)]
#![feature(maybe_uninit_array_assume_init)]

use std::mem::MaybeUninit;

fn main(){
    let mut a:[MaybeUninit<u8>; 4] = MaybeUninit::uninit_array();
    a[0].write(0);
    a[1].write(1);
    a[2].write(2);
    a[3].write(3);
    let b = u32::from_le_bytes(unsafe { MaybeUninit::array_assume_init(a) });
}
```
å¯¹åº” safe2
```
fn main(){
    let mut a:[u8; 4]=[0,1,2,4];
    let b = u32::from_le_bytes(a);
    println!("{}",b);
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

github unsafeï¼ˆä¸ä¸Šstd unsafe2 å¯¹åº”)
```
#[inline]
fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {
    let mut bytes = MaybeUninit::uninit_array();
    let _start_pos = decoder.position();
    decoder.read_raw_bytes(&mut bytes)?;

    let _end_pos = decoder.position();
    debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);

    let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });

    Ok(IntEncodedWithFixedSize(value))
}
```
github safe
```
#[inline]
fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {
    let mut bytes = MaybeUninit::uninit_array();
    let _start_pos = decoder.position();
    decoder.read_raw_bytes(&mut bytes)?;

    let _end_pos = decoder.position();
    debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);

    let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });

    Ok(IntEncodedWithFixedSize(value))
}
```
## as_bytes_mut(2)ï¼ˆ0ï¼‰
- unsafe1 è°ƒç”¨ String ç±»å‹çš„ as_bytes_mut() æ–¹æ³•ï¼Œå¹¶å°†å…¶è¿”å›çš„å¯å˜å­—èŠ‚æ•°ç»„ç»‘å®šåˆ°å˜é‡ä¸Š
  - safeæ–¹å¼ä½¿ç”¨ as_bytes æ–¹æ³•æ¥è·å–ä¸å¯å˜çš„å­—èŠ‚æ•°ç»„å¼•ç”¨
- unsafe2 ç›¸æ¯”1æ¥è¯´å¤šäº†å¯¹å­—ç¬¦çš„ä¿®æ”¹æ“ä½œ
  - safe æ–¹å¼å…ˆå°†å­—ç¬¦ä¸² s è½¬æ¢ä¸ºå¯å˜å­—ç¬¦ä¸²ï¼Œå†æ›¿æ¢å­—ç¬¦ï¼Œæœ€åå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¸å¯å˜çš„
  

è¡¥å…… unsafe 2.rs
```
fn main(){
    let mut s = String::from("ğŸ—»âˆˆğŸŒ");
    unsafe {
        let bytes = s.as_bytes_mut();
        bytes[0] = 0xF0;
        bytes[1] = 0x9F;
        bytes[2] = 0x8D;
        bytes[3] = 0x94;
    }
    assert_eq!("ğŸ”âˆˆğŸŒ", s);
}
```
å¯¹åº” safe 2.rs
```
fn main(){
    let mut s = String::from("ğŸ—»âˆˆğŸŒ");
// å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¯å˜å­—ç¬¦ä¸²
    let mut chars = s.chars().collect::<Vec<_>>();
// æ›¿æ¢ç¬¬ä¸€ä¸ªå­—ç¬¦
    chars[0] = 'ğŸ”';
// å°†å­—ç¬¦æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    s = chars.into_iter().collect();
    assert_eq!("ğŸ”âˆˆğŸŒ", s);
}
```
## as_chunks_unchecked (1)(0)
- unsafe1 as_chunks_unchecked æ–¹æ³•æ¥å°†ä¸€ä¸ªå­—ç¬¦åˆ‡ç‰‡åˆ†æˆå¤šä¸ªå›ºå®šå¤§å°çš„å—ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ•°ç»„çš„å¼•ç”¨
  - safeæ–¹å¼ä½¿ç”¨chunks_exactæ–¹æ³•å¯¹åˆ‡ç‰‡è¿›è¡Œåˆ‡åˆ†ï¼Œç¡®ä¿æ¯ä¸ªåˆ‡ç‰‡å—çš„é•¿åº¦éƒ½ç›¸ç­‰ä¸”ä¸è¶…è¿‡åŸå§‹åˆ‡ç‰‡çš„é•¿åº¦

## as_chunks_unchecked_mut(1)(0)
- unsafe1 åˆ›å»ºä¸€ä¸ªå¯å˜çš„å­—ç¬¦ sliceä½¿ç”¨as_chunks_unchecked_mut æ–¹æ³•æ¥å°†ä¸€ä¸ªå­—ç¬¦åˆ‡ç‰‡åˆ†æˆå¤šä¸ªå›ºå®šå¤§å°çš„å—,
  - safeæ–¹å¼ä½¿ç”¨chunks_exactæ–¹æ³•å¯¹åˆ‡ç‰‡è¿›è¡Œåˆ‡åˆ†

## as_ref(2)(0)
- unsafe1 é€šè¿‡as_ref()æ–¹æ³•å°†ä¸å¯å˜æŒ‡é’ˆè½¬åŒ–ä¸ºOption<&T>ç±»å‹
  - safeæ–¹å¼åˆ›å»ºä¸€ä¸ªæŒ‡å‘u8ç±»å‹å˜é‡10çš„ä¸å¯å˜æŒ‡é’ˆï¼Œå¹¶å°†å…¶å°è£…åˆ°Rcä¸­ï¼Œé€šè¿‡Deref traitè·å–æŒ‡é’ˆæ‰€æŒ‡å‘çš„å€¼
- unsafe2 ä½¿ç”¨as_ref()æ–¹æ³•å°†NonNullç±»å‹çš„æŒ‡é’ˆè½¬åŒ–ä¸ºå¼•ç”¨ç±»å‹
  - safeæ–¹å¼å°†å˜é‡åŒ…è£…æˆä¸€ä¸ªå¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆRcï¼Œä½¿ç”¨deref()æ–¹æ³•è·å–æŒ‡é’ˆå†…éƒ¨æ•°æ®çš„å¼•ç”¨
  -  - 1ã€2 ä¿®æ”¹æ–¹å¼æ— åŒºåˆ«
## as_uninit_ref(1)(0)
- unsafe1 å°†æŒ‡é’ˆè½¬åŒ–ä¸ºOption<MaybeUninit<&T>>ç±»å‹
  - safeæ–¹å¼ new()ç„¶åderef()
## assume_init(11)(1)
- unsafe1 (åŸ1 3 15 5 6)  Box::<u32>::new_uninit()
- unsafe19 ï¼ˆåŸ19 25 21ï¼‰  Rc::<u32>::new_uninit()
- 17 ï¼ˆåŸ17 18ï¼‰   MaybeUninit::<UnsafeCell<i32>>::uninit()
- 2  ï¼ˆåŸ2 4 7 8ï¼‰ Box::<u32>::new_zeroed()
- 10 ï¼ˆåŸ10 12 14ï¼‰ Box new_zeroed_slice(3) 
- 20 ï¼ˆåŸ20 22 ï¼‰   Rc::<u32>::new_zeroed() 
- 24               Rc new_zeroed_slice(3)
- 9  ï¼ˆåŸ9 16 11 13 ï¼‰ Box new_uninit_slice
- 23              Rc new_uninit_slice
- 26              MaybeUninit::uninit().assume_init()
   - æ–¹æ³•å‡ä¸ºç›´æ¥newä¸å†å»¶è¿Ÿåˆå§‹åŒ– 
   
è¡¥å……unsafe26ï¼ˆä¸GitHub caseå¯¹åº”ï¼‰
```
use std::mem::MaybeUninit;

fn main() {
    let mut v: [MaybeUninit<Vec<i32>>; 10] = unsafe { MaybeUninit::uninit().assume_init() };
}

```
å¯¹åº” safe26
```
fn main() {
    const EMPTY_VEC: Vec<i32> = Vec::new();
    let mut m = [EMPTY_VEC; 10];
}
```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Github unsafeï¼ˆä¸ä¸Šstd unsafe26 å¯¹åº”)
```
#![allow(unused)]
use std::mem::MaybeUninit;
fn main() {
    let mut m: [MaybeUninit<String>; 256] = unsafe { MaybeUninit::uninit().assume_init() };
}
```
Github safe
```
#![allow(unused)]
fn main() {
    const EMPTY_STRING: String = String::new();
    let mut m = [EMPTY_STRING; 256];
}
```
### dealloc(2)(0)

- unsafe1 æŠŠ Box è½¬æ¢æˆè£¸æŒ‡é’ˆï¼Œä½¿ç”¨drop_in_place æ‰‹åŠ¨è°ƒç”¨æŒ‡é’ˆæŒ‡å‘å¯¹è±¡çš„ææ„å‡½æ•°ï¼Œç„¶åä½¿ç”¨ dealloc å‡½æ•°é‡Šæ”¾æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜
  - safeæ–¹å¼ä¸º drop(p)
- unsafe2 å°† Box è½¬åŒ–ä¸ºè£¸æŒ‡é’ˆå’Œåˆ†é…å™¨ Box::into_raw_with_allocator(x)æœ€åé‡Šæ”¾åˆ†é…å™¨ä¸­çš„å†…å­˜alloc.deallocate
  - safeæ–¹å¼ä¸ºdrop(ptr)ã€drop(alloc)
  - -  1ã€2çš„ä¸»è¦åŒºåˆ«æ˜¯åˆ†é…æ–¹å¼å’Œé‡Šæ”¾å‡½æ•°ä¸åŒ
### downcast_unchecked(1)(0)
- unsafe1 ä½¿ç”¨äº† downcast_unchecked() æ–¹æ³•æ¥å°†å˜é‡ç±»å‹æ˜¯ Box\<dyn Any> çš„xä¸­çš„å€¼è½¬æ¢æˆ usize ç±»å‹
  - safeæ–¹å¼ä¸ºä½¿ç”¨ if let å’Œ downcast() æ–¹æ³•

### drop_in_place(4)(0)
- unsafe1 é‡Šæ”¾æŒ‡å‘å®ç°äº† Drop trait çš„stringçš„æŒ‡é’ˆ 
- unsafe2 é‡Šæ”¾åŸºæœ¬ç±»å‹ i32  çš„æŒ‡é’ˆ 
- unsafe3..18 é‡Šæ”¾ä½™ä¸‹16åŸºæœ¬ç±»å‹çš„æŒ‡é’ˆ
- unsafe19 é‡Šæ”¾è‡ªå®šä¹‰ç±»å‹Vec<u8> 
- unsafe20 é‡Šæ”¾åŒ…å«åœ¨Vecå®¹å™¨ä¸­çš„å¯¹è±¡ï¼ˆä¸Šè¿°å®¹å™¨å‡ä¸ºBoxï¼‰
---------------------------------------ä¿®æ”¹æ–¹æ³•å‡ä¸ºdropï¼ˆï¼‰
è¡¥å…… unsafe 2.rs
```
fn main() {
    let mut x = 123;
    let p = &mut x as *mut i32;
    // é€šè¿‡ &mut x å–å‡º x çš„å¯å˜å¼•ç”¨ï¼Œå¹¶å°†å…¶è½¬æ¢æˆäº†ä¸€ä¸ª *mut i32 ç±»å‹çš„åŸå§‹æŒ‡é’ˆ pï¼Œè¡¨ç¤ºæŒ‡å‘ x æ‰€åœ¨çš„å†…å­˜åœ°å€

    unsafe {
        std::ptr::drop_in_place(p);
        // æ‰‹åŠ¨é‡Šæ”¾äº† i32 ç±»å‹å¯¹è±¡æ‰€å ç”¨çš„å†…å­˜
    }
}

```
å¯¹åº” safe 2.rs 
```
fn main() {
    let mut x = 123;
    std::mem::drop(x);
}
```
è¡¥å…… unsafe 19.rs
```
// å®šä¹‰ä¸€ä¸ªåŒ…å« Vec<u8> æ•°æ®çš„è‡ªå®šä¹‰ç±»å‹ MyStruct
struct MyStruct {
    data: Vec<u8>,
}

// ä¸º MyStruct ç±»å‹å®ç° Drop trait
impl Drop for MyStruct {
    fn drop(&mut self) {
        // åœ¨å¯¹è±¡è¢«é‡Šæ”¾æ—¶æ‰“å°ä¸€æ¡æ¶ˆæ¯
        println!("Dropping MyStruct");
    }
}

fn main() {
    // åˆ›å»ºä¸€ä¸ª MyStruct å¯¹è±¡å¹¶åˆå§‹åŒ–å®ƒçš„ data å­—æ®µ
    let my_struct = MyStruct {
        data: vec![1, 2, 3],
    };

    // å°† MyStruct å¯¹è±¡è½¬æ¢ä¸º Boxï¼Œå¹¶è·å–å®ƒçš„åŸå§‹æŒ‡é’ˆ
    let ptr = Box::into_raw(Box::new(my_struct));

    // ä½¿ç”¨ unsafe å—å’Œ drop_in_place å‡½æ•°é‡Šæ”¾æŒ‡é’ˆæ‰€æŒ‡å‘çš„å¯¹è±¡çš„å†…å­˜
    unsafe {
        std::ptr::drop_in_place(ptr);
    }
}

```
å¯¹åº” safe 19.rs 
```
struct MyStruct {
    data: Vec<u8>,
}
impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Dropping MyStruct");
    }
}

fn main() {
    let my_struct = MyStruct {
        data: vec![1, 2, 3],
    };
    let ptr = Box::leak(Box::new(my_struct));
    std::mem::drop(ptr);
}

```
è¡¥å…… unsafe 20.rs
```
fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let p = v.as_mut_ptr();
    let len = v.len();
    // å¼ºåˆ¶å¿˜è®°è¿™ä¸ª Vecï¼Œä½¿å†…å­˜ä¸ä¼šè¢«è‡ªåŠ¨é‡Šæ”¾
    std::mem::forget(v);

    unsafe {
        for i in 0..len {
            std::ptr::drop_in_place(p.add(i));
        }
        std::alloc::dealloc(p as *mut u8, std::alloc::Layout::new::<i32>());
    }
}

```
å¯¹åº” safe 20.rs
```
fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let mut v = std::mem::take(&mut v); // é€šè¿‡takeå‡½æ•°è·å–Vecä¸­çš„æ‰€æœ‰æƒå¹¶å°†å…¶ç½®ä¸ºç©ºï¼Œé¿å…ä½¿ç”¨forgetå‡½æ•°
    while let Some(val) = v.pop() {  // é€šè¿‡popå‡½æ•°è·å–Vecä¸­çš„å…ƒç´ å¹¶é‡Šæ”¾
        drop(val);
    }
}

```
